<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - objects controls</title>
		<meta charset="utf-8">
		<style>
			body {
				margin: 0px;
				color: #fff;
				font-family:Monospace;
				text-align: center;
				font-size: 15px;
				line-height: 30px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 15px;
				z-index:100;
			}
		</style>
	</head>
	<body>
		<div id="info">
			<a href="http://threejs.org" target="_blank">three.js</a> - look console
		</div>

		<script src="../build/three.min.js"></script>
		<script src="js/loaders/MTLLoader.js"></script>
		<script src="js/loaders/OBJMTLLoader.js"></script>
		<script src="js/loaders/ColladaLoader.js"></script>


		<script src="js/libs/stats.min.js"></script>

		<script src="js/controls/OrbitControls.js"></script>		
		<script src="js/controls/EventsControls.js"></script>

		<script>


			var camera, scene, renderer, controls; 
			var model;

			var particleCount = 100;
			var particleSystem;

			init();
			animate();

			function init() {

				renderer = new THREE.WebGLRenderer( { antialias: true } ); 
				renderer.setClearColor( 0x6495ED );
				renderer.setSize( window.innerWidth, window.innerHeight );				
				document.body.appendChild( renderer.domElement );

				//

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				document.body.appendChild( stats.domElement );

				//

				camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 2000 );				
				camera.position.set( 100, 400, 600 );
				camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.rotateSpeed = 1;
				controls.noZoom = false;
				controls.zoomSpeed = 1.2;
				controls.staticMoving = true;
				controls.minPolarAngle = Math.PI / 3;
				controls.maxPolarAngle = Math.PI / 3;

				scene = new THREE.Scene();

				var light = new THREE.DirectionalLight( 0xffffff, 1 );
				light.position.set( 0, 500, 1000 );
				scene.add( light );

				var light = new THREE.AmbientLight( 0x222222 );
				scene.add( light );


				// world

				var Texture = new THREE.ImageUtils.loadTexture( 'textures/checkerboard.jpg' );
				Texture.wrapS = Texture.wrapT = THREE.RepeatWrapping;
				Texture.repeat.set( 4, 4 );	Texture.offset.set( 0.5, 0 );

				var Material = new THREE.MeshBasicMaterial( { map: Texture, side: THREE.DoubleSide } );
				var Geometry = new THREE.PlaneBufferGeometry( 400, 400, 1, 1 );

				var checkerboard = new THREE.Mesh( Geometry, Material );
				checkerboard.position.y = - 1;
				checkerboard.rotation.x =  Math.PI / 2;
				scene.add( checkerboard );


				EventsControls1 = new EventsControls( camera, renderer.domElement );
				EventsControls1.map = checkerboard;			
				EventsControls1.offsetUse = true;

				EventsControls1.attachEvent( 'onclick', function() {

					console.log( 'this.focused.name: ' + this.focused.name );

				});

				EventsControls1.attachEvent( 'mouseOver', function () {

					this.container.style.cursor = 'pointer';

				});

				EventsControls1.attachEvent( 'mouseOut', function () {

					this.container.style.cursor = 'auto';

				});

				EventsControls1.attachEvent( 'dragAndDrop', function () {

					this.container.style.cursor = 'move';
					this.focused.position.y = this.previous.y;
					//this.focused.position.x = 25 + 50 * Math.round( ( this.focused.position.x - 25 ) / 50 );
					//this.focused.position.z = 25 + 50 * Math.round( ( this.focused.position.z - 25 ) / 50 );

				});

				EventsControls1.attachEvent( 'mouseUp', function () {

					this.container.style.cursor = 'auto';

				});

				
				var loader = new THREE.OBJMTLLoader();	
				loader.load( 'models/bench/Bench3.obj', 'models/bench/Bench3.mtl', 
						function ( Bench ) {
						var material = new THREE.MeshLambertMaterial( { color: 0x8B4513 } );
						
						Bench.traverse( function ( child ) {
						if ( child instanceof THREE.Mesh ) {
							child.material = material;
						}

					} );
							Bench.position.set( 125, 35, 175 );
							Bench.scale.set( 1/30, 1/30, 1/30 );
							scene.add( Bench );  Bench.name = 'Bench';
							EventsControls1.attach( Bench );
						}
					);

				loader.load( 'models/objmtl/model.obj', 'models/objmtl/model.mtl', 
						function ( GingerbreadMan ) {
							GingerbreadMan.position.set( -125, 35, 175 );
							GingerbreadMan.scale.set( 1/3, 1/3, 1/3 );  GingerbreadMan.name = 'GingerbreadMan';
							scene.add( GingerbreadMan );
							EventsControls1.attach( GingerbreadMan );
						}
					);				
					
					

				var jsonLoader = new THREE.JSONLoader();
				jsonLoader.load( "models/Tux.js", addModelToScene );
								

					
	
				EventsControls2 = new EventsControls( camera, renderer.domElement );
				EventsControls2.map = checkerboard;	

				EventsControls2.attachEvent( 'mouseOver', function () {

					this.container.style.cursor = 'pointer';

				});

				EventsControls2.attachEvent( 'mouseOut', function () {

					this.container.style.cursor = 'auto';

				});

				EventsControls2.attachEvent( 'dragAndDrop', function () {

					this.container.style.cursor = 'move';
					this.focused.position.y = this.previous.y;

				});

								
					
				var loader = new THREE.ColladaLoader();	
				var Scale = new THREE.Vector3( 20, 20, 20 );
				EventsControls2.scale.copy( Scale );
				EventsControls2.offsetUse = true;
				
					loader.options.convertUpAxis = true;
					loader.load( 'models/monster/monster.dae', function ( collada ) {
						var dae = collada.scene;
						dae.position.set(0,0,0);
						dae.scale.set( 1/Scale.x, 1/Scale.y, 1/Scale.z );
						
						dae.updateMatrix();

						scene.add(dae); 
						EventsControls2.attach( dae );
					}); 

	

				EventsControls3 = new EventsControls( camera, renderer.domElement );
				EventsControls3.attach( checkerboard );

				EventsControls3.attachEvent( 'mouseOver', function () {

					controls.enabled = false;

				});

				EventsControls3.attachEvent( 'mouseOut', function () {

					controls.enabled = true;

				});
	
			}

			function addModelToScene( geometry, materials ) {

				var material = new THREE.MeshFaceMaterial( materials );
				model = new THREE.Mesh( geometry, material );
				model.scale.set( 10, 10, 10 ); model.name = 'Tux';
				model.rotation.x = -Math.PI/2; 
				model.position.set( -75, 45, 175  );
				scene.add( model ); EventsControls1.attach( model );
	
			}


			function animate() {

					requestAnimationFrame(animate);
					render();

			}


			function render() {

					stats.update();

					EventsControls1.update();
					EventsControls3.update();

					controls.update();
					renderer.render(scene, camera);

			}
					
		</script>

	</body>
</html>


